/*use std::marker::PhantomData;

use halo2_proofs::{
    arithmetic::FieldExt,
    circuit::{AssignedCell, Chip, Layouter, Region, SimpleFloorPlanner, Value},
    plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Fixed, Instance, Selector},
    poly::Rotation,
};

// ANCHOR: instructions
trait NumericInstructions<F: FieldExt>: Chip<F> {
    /// Variable representing a number.
    type Num;

    /// Loads a number into the circuit as a private input.
    fn load_private(&self, layouter: impl Layouter<F>, a: Value<F>) -> Result<Self::Num, Error>;

    /// Loads a number into the circuit as a fixed constant.
    fn load_constant(&self, layouter: impl Layouter<F>, constant: F) -> Result<Self::Num, Error>;

    /// Returns `c = a * b`.
    fn mul(
        &self,
        layouter: impl Layouter<F>,
        a: Self::Num,
        b: Self::Num,
        c: Self::Num,
    ) -> Result<Self::Num, Error>;

    /// Returns `c = a + b`.
    fn add(
        &self,
        layouter: impl Layouter<F>,
        a: Self::Num,
        b: Self::Num,
        c: Self::Num,
    ) -> Result<Self::Num, Error>;

    /// Exposes a number as a public input to the circuit.
    fn expose_public(
        &self,
        layouter: impl Layouter<F>,
        num: Self::Num,
        row: usize,
    ) -> Result<(), Error>;
}
// ANCHOR_END: instructions

// ANCHOR: chip
/// The chip that will implement our instructions! Chips store their own
/// config, as well as type markers if necessary.
struct FieldChip<F: FieldExt> {
    config: FieldConfig,
    _marker: PhantomData<F>,
}
// ANCHOR_END: chip

// ANCHOR: chip-config
/// Chip state is stored in a config struct. This is generated by the chip
/// during configuration, and then stored inside the chip.
#[derive(Clone, Debug)]
struct FieldConfig {
    /// For this chip, we will use two advice columns to implement our instructions.
    /// These are also the columns through which we communicate with other parts of
    /// the circuit.
    advice: [Column<Advice>; 3],

    fixed: [Column<Fixed>; 4],

    /// This is the public input (instance) column.
    instance: Column<Instance>,

    // We need a selector to enable the multiplication gate, so that we aren't placing
    // any constraints on cells where `NumericInstructions::mul` is not being used.
    // This is important when building larger circuits, where columns are used by
    // multiple sets of instructions.
    s_mul: Selector,
}

impl<F: FieldExt> FieldChip<F> {
    fn construct(config: <Self as Chip<F>>::Config) -> Self {
        Self {
            config,
            _marker: PhantomData,
        }
    }

    fn configure(
        meta: &mut ConstraintSystem<F>,
        advice: [Column<Advice>; 3],
        fixed: [Column<Fixed>; 4],
        instance: Column<Instance>,
        constant: Column<Fixed>,
    ) -> <Self as Chip<F>>::Config {
        meta.enable_equality(instance);
        meta.enable_constant(constant);
        for column in &advice {
            meta.enable_equality(*column);
        }
        let s_mul = meta.selector();

        // Define our multiplication gate!
        meta.create_gate("Combined add-mult", |meta| {
            // To implement multiplication, we need three advice cells and a selector
            // cell. We arrange them like so:
            //
            // | a0  | a1  | s_mul |
            // |-----|-----|-------|
            // | lhs | rhs | s_mul |
            // | out |     |       |
            //
            // Gates may refer to any relative offsets we want, but each distinct
            // offset adds a cost to the proof. The most common offsets are 0 (the
            // current row), 1 (the next row), and -1 (the previous row), for which
            // `Rotation` has specific constructors.
            let a = meta.query_advice(advice[0], Rotation::cur());
            let b = meta.query_advice(advice[1], Rotation::cur());
            let c = meta.query_advice(advice[2], Rotation::cur());

            let sa = meta.query_fixed(fixed[0], Rotation::cur());
            let sb = meta.query_fixed(fixed[1], Rotation::cur());
            let sc = meta.query_fixed(fixed[2], Rotation::cur());
            let sm = meta.query_fixed(fixed[3], Rotation::cur());
            
            let s_mul = meta.query_selector(s_mul);

            // Finally, we return the polynomial expressions that constrain this gate.
            // For our multiplication gate, we only need a single polynomial constraint.
            //
            // The polynomial expressions returned from `create_gate` will be
            // constrained by the proving system to equal zero. Our expression
            // has the following properties:
            // - When s_mul = 0, any value is allowed in lhs, rhs, and out.
            // - When s_mul != 0, this constrains lhs * rhs = out.
            vec![s_mul * (a.clone() * sa + b.clone() * sb + a * b * sm - (c * sc))]
        });

        FieldConfig {
            advice,
            fixed,
            instance,
            s_mul,
        }
    }
}
// ANCHOR_END: chip-config

// ANCHOR: chip-impl
impl<F: FieldExt> Chip<F> for FieldChip<F> {
    type Config = FieldConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}
// ANCHOR_END: chip-impl

// ANCHOR: instructions-impl
/// A variable representing a number.
#[derive(Clone)]
struct Number<F: FieldExt>(AssignedCell<F, F>);

impl<F: FieldExt> NumericInstructions<F> for FieldChip<F> {
    type Num = Number<F>;

    fn load_private(
        &self,
        mut layouter: impl Layouter<F>,
        value: Value<F>,
    ) -> Result<Self::Num, Error> {
        let config = self.config();

        layouter.assign_region(
            || "load private",
            |mut region| {
                region
                    .assign_advice(|| "private input", config.advice[0], 0, || value)
                    .map(Number)
            },
        )
    }

    fn load_constant(
        &self,
        mut layouter: impl Layouter<F>,
        constant: F,
    ) -> Result<Self::Num, Error> {
        let config = self.config();

        layouter.assign_region(
            || "load constant",
            |mut region| {
                region
                    .assign_advice_from_constant(|| "constant value", config.advice[0], 0, constant)
                    .map(Number)
            },
        )
    }

    fn mul(
        &self,
        mut layouter: impl Layouter<F>,
        a: Self::Num,
        b: Self::Num,
        c: Self::Num,
    ) -> Result<Self::Num, Error> {
        let config = self.config();

        layouter.assign_region(
            || "mul",
            |mut region: Region<'_, F>| {
                // We only want to use a single multiplication gate in this region,
                // so we enable it at region offset 0; this means it will constrain
                // cells at offsets 0 and 1.
                config.s_mul.enable(&mut region, 0)?;

                // The inputs we've been given could be located anywhere in the circuit,
                // but we can only rely on relative offsets inside this region. So we
                // assign new cells inside the region and constrain them to have the
                // same values as the inputs.
                a.0.copy_advice(|| "lhs", &mut region, config.advice[0], 0)?;
                b.0.copy_advice(|| "rhs", &mut region, config.advice[1], 0)?;

                region.assign_fixed(|| "a", config.fixed[0], 0, || Value::known(F::zero()))?;
                region.assign_fixed(|| "b", config.fixed[1], 0, || Value::known(F::zero()))?;
                region.assign_fixed(|| "c", config.fixed[2], 0, || Value::known(F::one()))?;
                region.assign_fixed(
                    || "a * b",
                    config.fixed[3],
                    0,
                    || Value::known(F::one()),
                )?;

                // Now we can assign the multiplication result, which is to be assigned
                // into the output position.
                let value = a.0.value().copied() * b.0.value();

                // Finally, we do the assignment to the output, returning a
                // variable to be used in another part of the circuit.
                c.0.copy_advice(|| "lhs * rhs", &mut region, config.advice[2], 0)
                    .map(Number)
            },
        )
    }

    fn add(
        &self,
        mut layouter: impl Layouter<F>,
        a: Self::Num,
        b: Self::Num,
        c: Self::Num,
    ) -> Result<Self::Num, Error> {
        let config = self.config();

        layouter.assign_region(
            || "mul",
            |mut region: Region<'_, F>| {
                // We only want to use a single multiplication gate in this region,
                // so we enable it at region offset 0; this means it will constrain
                // cells at offsets 0 and 1.
                config.s_mul.enable(&mut region, 0)?;

                // The inputs we've been given could be located anywhere in the circuit,
                // but we can only rely on relative offsets inside this region. So we
                // assign new cells inside the region and constrain them to have the
                // same values as the inputs.
                a.0.copy_advice(|| "lhs", &mut region, config.advice[0], 0)?;
                b.0.copy_advice(|| "rhs", &mut region, config.advice[1], 0)?;

                region.assign_fixed(|| "a", config.fixed[0], 0, || Value::known(F::one()))?;
                region.assign_fixed(|| "b", config.fixed[1], 0, || Value::known(F::one()))?;
                region.assign_fixed(|| "c", config.fixed[2], 0, || Value::known(F::zero()))?;
                region.assign_fixed(
                    || "a + b",
                    config.fixed[3],
                    0,
                    || Value::known(F::one()),
                )?;

                // Finally, we do the assignment to the output, returning a
                // variable to be used in another part of the circuit.
                c.0.copy_advice(|| "lhs + rhs", &mut region, config.advice[2], 0).map(Number)
            },
        )
    }

    fn expose_public(
        &self,
        mut layouter: impl Layouter<F>,
        num: Self::Num,
        row: usize,
    ) -> Result<(), Error> {
        let config = self.config();

        layouter.constrain_instance(num.0.cell(), config.instance, row)
    }
}
// ANCHOR_END: instructions-impl

// ANCHOR: circuit
/// The full circuit implementation.
///
/// In this struct we store the private input variables. We use `Option<F>` because
/// they won't have any value during key generation. During proving, if any of these
/// were `None` we would get an error.
#[derive(Default)]
struct MyCircuit<F: FieldExt> {
    constant: F,
    a: Value<F>,
    b: Value<F>,
}

impl<F: FieldExt> Circuit<F> for MyCircuit<F> {
    // Since we are using a single chip for everything, we can just reuse its config.
    type Config = FieldConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        // We create the three advice columns that FieldChip uses for I/O.
        let advice = [
            meta.advice_column(),
            meta.advice_column(),
            meta.advice_column(),
        ];

        // We create the four fixed columns that FieldChip uses for fixed coefficients.
        let fixed = [
            meta.fixed_column(),
            meta.fixed_column(),
            meta.fixed_column(),
            meta.fixed_column(),
        ];

        // We also need an instance column to store public inputs.
        let instance = meta.instance_column();

        // Create a fixed column to load constants.
        let constant = meta.fixed_column();

        FieldChip::configure(meta, advice, fixed, instance, constant)
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        let field_chip = FieldChip::<F>::construct(config);

        // Load our private values into the circuit.
        let a = field_chip.load_private(layouter.namespace(|| "load a"), self.a)?;
        let b = field_chip.load_private(layouter.namespace(|| "load b"), self.b)?;

        // Load the constant factor into the circuit.
        let constant =
            field_chip.load_constant(layouter.namespace(|| "load constant"), self.constant)?;

        // We only have access to plain multiplication.
        // We could implement our circuit as:
        //     asq  = a*a
        //     bsq  = b*b
        //     absq = asq*bsq
        //     c    = constant*asq*bsq
        //
        // but it's more efficient to implement it as:
        //     ab   = a*b
        //     absq = ab^2
        //     c    = constant*absq
        let ab = field_chip.mul(layouter.namespace(|| "a * b"), a, b)?;
        let absq = field_chip.mul(layouter.namespace(|| "ab * ab"), ab.clone(), ab)?;
        let c = field_chip.mul(layouter.namespace(|| "constant * absq"), constant, absq)?;

        // Expose the result as a public input to the circuit.
        field_chip.expose_public(layouter.namespace(|| "expose c"), c, 0)
    }
}
// ANCHOR_END: circuit

fn main() {
    use halo2_proofs::{dev::MockProver, pasta::Fp};

    // ANCHOR: test-circuit
    // The number of rows in our circuit cannot exceed 2^k. Since our example
    // circuit is very small, we can pick a very small value here.
    let k = 4;

    // Prepare the private and public inputs to the circuit!
    let constant = Fp::from(7);
    let a = Fp::from(2);
    let b = Fp::from(3);
    let c = constant * a.square() * b.square();

    // Instantiate the circuit with the private inputs.
    let circuit = MyCircuit {
        constant,
        a: Value::known(a),
        b: Value::known(b),
    };

    // Arrange the public input. We expose the multiplication result in row 0
    // of the instance column, so we position it there in our public inputs.
    let mut public_inputs = vec![c];

    // Given the correct public input, our circuit will verify.
    let prover = MockProver::run(k, &circuit, vec![public_inputs.clone()]).unwrap();
    assert_eq!(prover.verify(), Ok(()));

    // If we try some other public input, the proof will fail!
    public_inputs[0] += Fp::one();
    let prover = MockProver::run(k, &circuit, vec![public_inputs]).unwrap();
    assert!(prover.verify().is_err());
    // ANCHOR_END: test-circuit
}
*/

use group::ff::Field;
use halo2_proofs::arithmetic::FieldExt;
use halo2_proofs::circuit::{Cell, Layouter, SimpleFloorPlanner, Value};
use halo2_proofs::pasta::{EqAffine, Fp};
use halo2_proofs::plonk::*;
use halo2_proofs::poly::{commitment::Params, Rotation};
use halo2_proofs::transcript::{Blake2bRead, Blake2bWrite, Challenge255};
use rand_core::OsRng;

use num_bigint::BigInt;
use num_traits::Signed;

use std::marker::PhantomData;
use std::collections::{HashMap, BTreeMap};
use std::collections::btree_map::Entry;

use crate::ast::{VariableId, Module, Expr, InfixOp};
use crate::transform::collect_module_variables;

// Make field elements from signed values
fn make_constant<F: FieldExt>(c: BigInt) -> F {
    let bytes = c.magnitude().to_bytes_le();
    let magnitude = F::from_bytes_wide(&bytes.try_into().unwrap());
    if c.is_positive() {
        magnitude
    } else {
        -magnitude
    }
}

/// This represents an advice column at a certain row in the ConstraintSystem
#[derive(Copy, Clone, Debug)]
pub struct Variable(Column<Advice>, usize);

#[derive(Clone)]
struct PlonkConfig {
    a: Column<Advice>,
    b: Column<Advice>,
    c: Column<Advice>,

    sl: Column<Fixed>,
    sr: Column<Fixed>,
    so: Column<Fixed>,
    sm: Column<Fixed>,
    sc: Column<Fixed>,
}

trait StandardCs<FF: FieldExt> {
    fn raw_multiply<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<(Assigned<FF>, Assigned<FF>, Assigned<FF>)>;
    fn raw_add<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<(Assigned<FF>, Assigned<FF>, Assigned<FF>)>;
    fn raw_poly<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<PolyGate<Assigned<FF>>>;
    fn copy(&self, layouter: &mut impl Layouter<FF>, a: Cell, b: Cell) -> Result<(), Error>;
}

#[derive(Clone)]
struct MyCircuit<F: FieldExt> {
    pub module: Module,
    variable_map: HashMap<VariableId, Value<F>>,
    k: u32,
}

struct StandardPlonk<F: FieldExt> {
    config: PlonkConfig,
    _marker: PhantomData<F>,
}

impl<FF: FieldExt> StandardPlonk<FF> {
    fn new(config: PlonkConfig) -> Self {
        StandardPlonk {
            config,
            _marker: PhantomData,
        }
    }
}

#[derive(Copy, Clone)]
struct PolyGate<F> {
    a: F,
    b: F,
    c: F,
    q_m: F,
    q_l: F,
    q_r: F,
    q_o: F,
    q_c: F,
}

impl<FF: FieldExt> StandardCs<FF> for StandardPlonk<FF> {
    fn raw_multiply<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        mut f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<(Assigned<FF>, Assigned<FF>, Assigned<FF>)>,
    {
        layouter.assign_region(
            || "raw_multiply",
            |mut region| {
                let mut value = None;
                let lhs = region.assign_advice(
                    || "lhs",
                    self.config.a,
                    0,
                    || {
                        value = Some(f());
                        value.unwrap().map(|v| v.0)
                    },
                )?;
                let rhs = region.assign_advice(
                    || "rhs",
                    self.config.b,
                    0,
                    || value.unwrap().map(|v| v.1),
                )?;
                let out = region.assign_advice(
                    || "out",
                    self.config.c,
                    0,
                    || value.unwrap().map(|v| v.2),
                )?;

                region.assign_fixed(|| "a", self.config.sl, 0, || Value::known(FF::zero()))?;
                region.assign_fixed(|| "b", self.config.sr, 0, || Value::known(FF::zero()))?;
                region.assign_fixed(|| "c", self.config.so, 0, || Value::known(FF::one()))?;
                region.assign_fixed(
                    || "a * b",
                    self.config.sm,
                    0,
                    || Value::known(FF::one()),
                )?;
                Ok((lhs.cell(), rhs.cell(), out.cell()))
            },
        )
    }
    fn raw_add<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        mut f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<(Assigned<FF>, Assigned<FF>, Assigned<FF>)>,
    {
        layouter.assign_region(
            || "raw_add",
            |mut region| {
                let mut value = None;
                let lhs = region.assign_advice(
                    || "lhs",
                    self.config.a,
                    0,
                    || {
                        value = Some(f());
                        value.unwrap().map(|v| v.0)
                    },
                )?;
                let rhs = region.assign_advice(
                    || "rhs",
                    self.config.b,
                    0,
                    || value.unwrap().map(|v| v.1),
                )?;
                let out = region.assign_advice(
                    || "out",
                    self.config.c,
                    0,
                    || value.unwrap().map(|v| v.2),
                )?;

                region.assign_fixed(|| "a", self.config.sl, 0, || Value::known(FF::one()))?;
                region.assign_fixed(|| "b", self.config.sr, 0, || Value::known(FF::one()))?;
                region.assign_fixed(|| "c", self.config.so, 0, || Value::known(FF::one()))?;
                region.assign_fixed(
                    || "a + b",
                    self.config.sm,
                    0,
                    || Value::known(FF::zero()),
                )?;
                Ok((lhs.cell(), rhs.cell(), out.cell()))
            },
        )
    }
    fn raw_poly<F>(
        &self,
        layouter: &mut impl Layouter<FF>,
        mut f: F,
    ) -> Result<(Cell, Cell, Cell), Error>
    where
        F: FnMut() -> Value<PolyGate<Assigned<FF>>>,
    {
        layouter.assign_region(
            || "raw_poly",
            |mut region| {
                let mut value = None;
                let lhs = region.assign_advice(
                    || "lhs",
                    self.config.a,
                    0,
                    || {
                        value = Some(f());
                        value.unwrap().map(|v| v.a)
                    },
                )?;
                let rhs = region.assign_advice(
                    || "rhs",
                    self.config.b,
                    0,
                    || value.unwrap().map(|v| v.b),
                )?;
                let out = region.assign_advice(
                    || "out",
                    self.config.c,
                    0,
                    || value.unwrap().map(|v| v.c),
                )?;

                region.assign_fixed(|| "a", self.config.sl, 0, || value.unwrap().map(|v| v.q_l))?;
                region.assign_fixed(|| "b", self.config.sr, 0, || value.unwrap().map(|v| v.q_r))?;
                region.assign_fixed(|| "c", self.config.so, 0, || value.unwrap().map(|v| v.q_o))?;
                region.assign_fixed(
                    || "a * b",
                    self.config.sm,
                    0,
                    || value.unwrap().map(|v| v.q_m),
                )?;
                region.assign_fixed(|| "q_c", self.config.sc, 0, || value.unwrap().map(|v| v.q_c))?;
                Ok((lhs.cell(), rhs.cell(), out.cell()))
            },
        )
    }
    fn copy(
        &self,
        layouter: &mut impl Layouter<FF>,
        left: Cell,
        right: Cell,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "copy", |mut region| region.constrain_equal(left, right))
    }
}

impl<F: FieldExt> MyCircuit<F> {
    /* Make new circuit with default assignments to all variables in module. */
    pub fn new(module: Module) -> Self {
        let mut variables = HashMap::new();
        collect_module_variables(&module, &mut variables);
        let mut variable_map = HashMap::new();
        for variable in variables.keys() {
            variable_map.insert(*variable, Value::unknown());
        }
        let mut circuit_size = module.exprs.len();
        let mut k = 0;
        while circuit_size > 0 {
            circuit_size >>= 1;
            k += 1;
        }
        Self { module, variable_map, k }
    }

    /* Populate input and auxilliary variables from the given program inputs. */
    /*pub fn populate_variables(
        &mut self,
        mut field_assigns: HashMap<VariableId, F>,
    ) {
        // Get the definitions necessary to populate auxiliary variables
        let mut definitions = HashMap::new();
        for def in &self.module.defs {
            if let Pattern::Variable(var) = &def.0.0 {
                definitions.insert(var.id, *def.0.1.clone());
            }
        }
        // Start deriving witnesses
        for (var, value) in &mut self.variable_map {
            let var_expr = Expr::Variable(crate::ast::Variable::new(*var)).into();
            *value = evaluate_expr(&var_expr, &mut definitions, &mut field_assigns);
        }
    }*/
}

fn copy_variable<F: FieldExt>(
    var: VariableId,
    cell: Cell,
    map: &mut BTreeMap<VariableId, Cell>,
    cs: &impl StandardCs<F>,
    layouter: &mut impl Layouter<F>,) -> Result<(), Error>
{
    match map.entry(var) {
        Entry::Vacant(vac) => {
            vac.insert(cell);
        },
        Entry::Occupied(occ) => {
            cs.copy(layouter, cell, *occ.get())?
        },
    }
    Ok(())
}

impl<F: FieldExt> MyCircuit<F> {
    fn make_gate(
        &self, a: Option<VariableId>, b: Option<VariableId>, c: Option<VariableId>,
        sl: F, sr: F, so: F, sm: F, sc: F, cell0: Cell,
        inputs: &mut BTreeMap<VariableId, Cell>, cs: &impl StandardCs<F>,
        layouter: &mut impl Layouter<F>,
    ) -> Result<(), Error> {
        
        let (c1, c2, c3) = cs.raw_poly(layouter, || {
            let a: Value<Assigned<_>> = a.map(|v1| self.variable_map[&v1])
                .unwrap_or(Value::known(F::zero())).into();
            let b: Value<Assigned<_>> = b.map(|v2| self.variable_map[&v2])
                .unwrap_or(Value::known(F::zero())).into();
            let c: Value<Assigned<_>> = c.map(|v3| self.variable_map[&v3])
                .unwrap_or(Value::known(F::zero())).into();
            a.zip(b).zip(c).map(|((a, b), c)| PolyGate {a, b, c, q_l:sl.into(), q_r:sr.into(), q_o:so.into(), q_m:sm.into(), q_c:sc.into()})
        })?;
        if let Some(v1) = a {
            copy_variable(v1, c1, inputs, cs, layouter)?;
        } else {
            cs.copy(layouter, c1, cell0)?;
        }
        if let Some(v2) = b {
            copy_variable(v2, c2, inputs, cs, layouter)?;
        } else {
            cs.copy(layouter, c2, cell0)?;
        }
        if let Some(v3) = c {
            copy_variable(v3, c3, inputs, cs, layouter)?;
        } else {
            cs.copy(layouter, c3, cell0)?;
        }
        Ok(())
    }
}

impl<F: FieldExt + Field> Circuit<F> for MyCircuit<F> {
    type Config = PlonkConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        let mut variable_map = self.variable_map.clone();
        for val in variable_map.values_mut() {
            *val = Value::unknown();
        }
        Self {
            variable_map,
            module: self.module.clone(),
            k: self.k,
        }
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> PlonkConfig {
        meta.set_minimum_degree(5);

        let a = meta.advice_column();
        let b = meta.advice_column();
        let c = meta.advice_column();

        meta.enable_equality(a);
        meta.enable_equality(b);
        meta.enable_equality(c);

        let sm = meta.fixed_column();
        let sl = meta.fixed_column();
        let sr = meta.fixed_column();
        let so = meta.fixed_column();
        let sc = meta.fixed_column();

        meta.create_gate("Combined add-mult", |meta| {
            let a = meta.query_advice(a, Rotation::cur());
            let b = meta.query_advice(b, Rotation::cur());
            let c = meta.query_advice(c, Rotation::cur());

            let sl = meta.query_fixed(sl, Rotation::cur());
            let sr = meta.query_fixed(sr, Rotation::cur());
            let so = meta.query_fixed(so, Rotation::cur());
            let sm = meta.query_fixed(sm, Rotation::cur());
            let sc = meta.query_fixed(sc, Rotation::cur());

            vec![a.clone() * sl + b.clone() * sr + a * b * sm + (c * so) + sc]
        });

        PlonkConfig {
            a,
            b,
            c,
            sl,
            sr,
            so,
            sm,
            sc,
        }
    }

    fn synthesize(
        &self,
        config: PlonkConfig,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        let cs = StandardPlonk::new(config);

        let mut inputs = BTreeMap::new();

        let val1: Assigned<_> = Assigned::from(F::one());
        let val0: Assigned<_> = Assigned::from(F::zero());
        let (cell0, cell0b, cell0c) = cs.raw_poly(&mut layouter, || {
            Value::known(PolyGate {
                a: val0,
                b: val0,
                c: val0,
                q_l: val0,
                q_r: val1,
                q_o: val0,
                q_m: val0,
                q_c: val0,
            })
        })?;
        cs.copy(&mut layouter, cell0, cell0b)?;
        cs.copy(&mut layouter, cell0b, cell0c)?;
        
        for expr in &self.module.exprs {
            if let Expr::Infix(InfixOp::Equal, lhs, rhs) = &expr.v {
                match (&lhs.v, &rhs.v) {
                    // Variables on the LHS
                    // v1 = v2
                    (
                        Expr::Variable(v1),
                        Expr::Variable(v2),
                    ) => {
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), -F::one(), F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                    },
                    // v1 = c2
                    (
                        Expr::Variable(v1),
                        Expr::Constant(c2),
                    ) => {
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -op2, cell0, &mut inputs, &cs, &mut layouter)?;
                    },
                    // v1 = -c2
                    (
                        Expr::Variable(v1),
                        Expr::Negate(e2),
                    ) if matches!(&e2.v, Expr::Constant(c2) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = -v2
                    (
                        Expr::Variable(v1),
                        Expr::Negate(e2),
                    ) if matches!(&e2.v, Expr::Variable(v2) if {
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), F::one(), F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 + c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::one(), F::zero(), F::zero(), -op2-op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 + c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), -F::one(), F::zero(), F::zero(), -op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 + v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v1.id), Some(v3.id), None, F::one(), -F::one(), F::zero(), F::zero(), -op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 + v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        self.make_gate(Some(v1.id), Some(v2.id), Some(v3.id), F::one(), -F::one(), -F::one(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 - c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op3-op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 - c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), -F::one(), F::zero(), F::zero(), op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 - v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v1.id), Some(v3.id), None, F::one(), F::one(), F::zero(), F::zero(), -op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 - v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        self.make_gate(Some(v1.id), Some(v2.id), Some(v3.id), F::one(), -F::one(), F::one(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 / c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c2.clone());
                        let op2: F = make_constant(c3.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -(op1*op2.invert().unwrap()), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 / c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op2: F = make_constant(c3.clone());
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), -op2.invert().unwrap(), F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 / v3 ***
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v1.id), Some(v3.id), None, F::zero(), F::zero(), F::zero(), F::one(), -op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 / v3 ***
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        self.make_gate(Some(v1.id), Some(v3.id), Some(v2.id), F::zero(), F::zero(), -F::one(), F::one(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 * c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c2.clone());
                        let op2: F = make_constant(c3.clone());
                        self.make_gate(Some(v1.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -(op1*op2), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 * c3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op2: F = make_constant(c3.clone());
                        self.make_gate(Some(v1.id), Some(v2.id), None, F::one(), -op2, F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = c2 * v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op2: F = make_constant(c2.clone());
                        self.make_gate(Some(v1.id), Some(v3.id), None, F::one(), -op2, F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // v1 = v2 * v3
                    (
                        Expr::Variable(v1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        self.make_gate(Some(v2.id), Some(v3.id), Some(v1.id), F::zero(), F::zero(), F::one(), -F::one(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // Now for constants on the LHS
                    // c1 = v2
                    (
                        Expr::Constant(c1),
                        Expr::Variable(v2),
                    ) => {
                        let op1: F = make_constant::<F>(c1.clone());
                        self.make_gate(Some(v2.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                    },
                    // c1 = c2
                    (
                        Expr::Constant(c1),
                        Expr::Constant(c2),
                    ) => {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1-op2, cell0, &mut inputs, &cs, &mut layouter)?;
                    },
                    // c1 = -c2
                    (
                        Expr::Constant(c1),
                        Expr::Negate(e2),
                    ) if matches!(&e2.v, Expr::Constant(c2) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1+op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = -v2
                    (
                        Expr::Constant(c1),
                        Expr::Negate(e2),
                    ) if matches!(&e2.v, Expr::Variable(v2) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        self.make_gate(Some(v2.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 + c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1-op2-op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 + c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v2.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op3-op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 + v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v3.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op2-op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 + v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Add, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        self.make_gate(Some(v2.id), Some(v3.id), None, F::one(), F::one(), F::zero(), F::zero(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 - c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1-op2+op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 - c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op3: F = make_constant::<F>(c3.clone());
                        self.make_gate(Some(v2.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -op1-op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 - v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        let op2: F = make_constant::<F>(c2.clone());
                        self.make_gate(Some(v3.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), op1-op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 - v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Subtract, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant::<F>(c1.clone());
                        self.make_gate(Some(v2.id), Some(v3.id), None, F::one(), -F::one(), F::zero(), F::zero(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 / c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op2: F = make_constant(c2.clone());
                        let op3: F = make_constant(c3.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1*op3-op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 / c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op3: F = make_constant(c3.clone());
                        self.make_gate(Some(v2.id), None, None, F::one(), F::zero(), F::zero(), F::zero(), -op1*op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 / v3 ***
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op2: F = make_constant(c2.clone());
                        self.make_gate(Some(v3.id), None, None, op1, F::zero(), F::zero(), F::zero(), -op2, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 / v3 ***
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Divide, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        self.make_gate(Some(v2.id), Some(v3.id), None, F::one(), -op1, F::zero(), F::zero(), F::zero(), cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 * c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op2: F = make_constant(c2.clone());
                        let op3: F = make_constant(c3.clone());
                        self.make_gate(None, None, None, F::zero(), F::zero(), F::zero(), F::zero(), op1-op2*op3, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 * c3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Constant(c3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op3: F = make_constant(c3.clone());
                        self.make_gate(Some(v2.id), None, None, op3, F::zero(), F::zero(), F::zero(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = c2 * v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Constant(c2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        let op2: F = make_constant(c2.clone());
                        self.make_gate(Some(v3.id), None, None, op2, F::zero(), F::zero(), F::zero(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    // c1 = v2 * v3
                    (
                        Expr::Constant(c1),
                        Expr::Infix(InfixOp::Multiply, e2, e3),
                    ) if matches!((&e2.v, &e3.v), (
                        Expr::Variable(v2),
                        Expr::Variable(v3),
                    ) if {
                        let op1: F = make_constant(c1.clone());
                        self.make_gate(Some(v2.id), Some(v3.id), None, F::zero(), F::zero(), F::zero(), F::one(), -op1, cell0, &mut inputs, &cs, &mut layouter)?;
                        true
                    }) => {},
                    _ => panic!("unsupported constraint encountered: {}", expr)
                }
            }
        }

        Ok(())
    }
}

fn keygen(module: Module) -> (Params<EqAffine>, ProvingKey<EqAffine>) {
    let empty_circuit: MyCircuit<Fp> = MyCircuit::new(module);
    let params: Params<EqAffine> = Params::new(empty_circuit.k);
    let vk = keygen_vk(&params, &empty_circuit).expect("keygen_vk should not fail");
    let pk = keygen_pk(&params, vk, &empty_circuit).expect("keygen_pk should not fail");
    (params, pk)
}

fn prover(module: Module, params: &Params<EqAffine>, pk: &ProvingKey<EqAffine>) -> Vec<u8> {
    let rng = OsRng;

    let circuit: MyCircuit<Fp> = MyCircuit::new(module);

    let mut transcript = Blake2bWrite::<_, _, Challenge255<_>>::init(vec![]);
    create_proof(params, pk, &[circuit], &[&[]], rng, &mut transcript)
        .expect("proof generation should not fail");
    transcript.finalize()
}

fn verifier(params: &Params<EqAffine>, vk: &VerifyingKey<EqAffine>, proof: &[u8]) {
    let strategy = SingleVerifier::new(params);
    let mut transcript = Blake2bRead::<_, _, Challenge255<_>>::init(proof);
    assert!(verify_proof(params, vk, strategy, &[&[]], &mut transcript).is_ok());
}

fn main2(module: Module) {
    let k_range = 8..=16;

    for k in k_range.clone() {
        let (params, pk) = keygen(module.clone());
    }

    for k in k_range {
        let (params, pk) = keygen(module.clone());
        let proof = prover(module.clone(), &params, &pk);
    }
}
